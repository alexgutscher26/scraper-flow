import crypto from "crypto";

type Redaction = { masked: string; fingerprint?: string };

const emailRegex = /\b([A-Za-z0-9._%+-])([A-Za-z0-9._%+-]*?)@([A-Za-z0-9.-]+\.[A-Za-z]{2,})\b/g;
const phoneRegex = /\b(?:\+?\d{1,3}[\s-]?)?(?:\(?\d{3}\)?[\s-]?\d{3}[\s-]?\d{4}|\d{10})\b/g;
const ssnRegex = /\b\d{3}-\d{2}-\d{4}\b/g;
const jwtRegex = /\b([A-Za-z0-9-_]{10,})\.([A-Za-z0-9-_]{10,})\.([A-Za-z0-9-_]{10,})\b/g;
const apiKeyRegex = /\b(?:api[_-]?key|x[-_]api[-_]key|authorization|bearer|token|secret|client[-_]secret)\b[^\n]*?(:|=)\s*([^\s,'";]+)/gi;
const ibanRegex = /\b[A-Z]{2}\d{2}[A-Z0-9]{1,30}\b/g;
const mrnRegex = /\b(?:mrn|medical_record_number)\b[^\n]*?(:|=)\s*(\d{6,10})/gi;
const icdRegex = /\b([A-TV-Z][0-9][A-Z0-9](?:\.?[A-Z0-9]{0,4})?)\b/g;

/**
 * Generates a HMAC hash of the input string using a key from the environment variable.
 */
function hmac(input: string): string {
  const key = process.env.LOG_HASH_KEY || "";
  const h = key
    ? crypto.createHmac("sha256", key).update(input).digest("hex")
    : crypto.createHash("sha256").update(input).digest("hex");
  return h.slice(0, 12);
}

/**
 * Validates a credit card number using the Luhn algorithm.
 *
 * This function takes a string representation of a credit card number, removes any non-digit characters,
 * and checks if the resulting number has a valid length (between 12 and 19 digits). It then calculates
 * the checksum using the Luhn algorithm and returns true if the number is valid, or false otherwise.
 *
 * @param value - The credit card number as a string to be validated.
 */
function luhn(value: string): boolean {
  const digits = value.replace(/\D/g, "");
  if (digits.length < 12 || digits.length > 19) return false;
  let sum = 0;
  let alt = false;
  for (let i = digits.length - 1; i >= 0; i--) {
    let n = parseInt(digits[i], 10);
    if (alt) {
      n *= 2;
      if (n > 9) n -= 9;
    }
    sum += n;
    alt = !alt;
  }
  return sum % 10 === 0;
}

/**
 * Masks digits in the input string while preserving a specified number of visible suffix digits.
 *
 * The function splits the input into groups of digits and non-digits, then processes each group.
 * It replaces digits with asterisks based on the total number of digits and the specified visibleSuffix.
 * Finally, it returns an object containing the masked string and a fingerprint generated by the hmac function.
 *
 * @param {string} input - The input string to be masked.
 * @param {number} [visibleSuffix=4] - The number of digits to keep visible at the end of the masked string.
 */
function maskPreserveGroups(input: string, visibleSuffix = 4): Redaction {
  const groups = input.match(/\d+|\D+/g) || [input];
  let digitsSeen = 0;
  const totalDigits = (input.match(/\d/g) || []).length;
  const keep = Math.min(visibleSuffix, totalDigits);
  const res = groups
    .map((g) => {
      if (!/\d/.test(g)) return g.replace(/[^\s]/g, (c) => c);
      return g
        .split("")
        .map((ch) => {
          if (!/\d/.test(ch)) return ch;
          const remaining = totalDigits - digitsSeen;
          const show = remaining <= keep;
          digitsSeen++;
          return show ? ch : "*";
        })
        .join("");
    })
    .join("");
  return { masked: res, fingerprint: hmac(input) };
}

/**
 * Redacts the local part of an email address while preserving the domain and generating a fingerprint.
 */
function redactEmail(match: string, first: string, rest: string, domain: string): string {
  const maskedLocal = `${first}${rest.replace(/./g, "*")}`;
  const fp = hmac(match);
  return `${maskedLocal}@${domain} [fp:${fp}]`;
}

/** Redacts the SSN by masking the first five digits and appending a fingerprint. */
function redactSSN(match: string): string {
  const suffix = match.slice(-4);
  const masked = `***-**-${suffix}`;
  const fp = hmac(match);
  return `${masked} [fp:${fp}]`;
}

/**
 * Redacts a JWT by masking its parts and appending a fingerprint.
 */
function redactJWT(match: string): string {
  const parts = match.split(".");
  const masked = `${parts[0].slice(0, 4)}***.${parts[1].slice(0, 4)}***.${parts[2].slice(0, 4)}***`;
  const fp = hmac(match);
  return `${masked} [fp:${fp}]`;
}

/**
 * Redacts a key pair value and generates a fingerprint.
 */
function redactKeyPair(_: string, __: string, value: string): string {
  const fp = hmac(value);
  const masked = value.length <= 8 ? "*".repeat(value.length) : `${value.slice(0, 4)}${"*".repeat(Math.max(0, value.length - 8))}${value.slice(-4)}`;
  return `${masked} [fp:${fp}]`;
}

/**
 * Sanitizes a given string by redacting sensitive information.
 *
 * The function processes the input string to replace occurrences of sensitive data such as email addresses,
 * social security numbers, JSON Web Tokens, API keys, IBANs, medical record numbers, and phone numbers
 * with masked versions. It utilizes various regex patterns and helper functions to ensure that the
 * sensitive information is properly redacted while preserving some identifiable structure.
 *
 * @param input - The string to be sanitized.
 */
export function sanitizeString(input: string): string {
  let s = input;
  s = s.replace(emailRegex, redactEmail as any);
  s = s.replace(ssnRegex, (m) => redactSSN(m));
  s = s.replace(jwtRegex, (m) => redactJWT(m));
  s = s.replace(apiKeyRegex, (m, k, v) => m.replace(v, redactKeyPair(m, k, v)));
  s = s.replace(ibanRegex, (m) => {
    const r = maskPreserveGroups(m);
    return `${r.masked} [fp:${r.fingerprint}]`;
  });
  s = s.replace(mrnRegex, (m, k, v) => m.replace(v, (() => {
    const fp = hmac(v);
    const masked = `${"*".repeat(Math.max(0, v.length - 2))}${v.slice(-2)}`;
    return `${masked} [fp:${fp}]`;
  })()));
  s = s.replace(phoneRegex, (m) => {
    const digits = m.replace(/\D/g, "");
    if (digits.length < 10) return m;
    const r = maskPreserveGroups(m);
    return `${r.masked} [fp:${r.fingerprint}]`;
  });
  s = s.replace(/\b\d{12,19}\b/g, (m) => {
    if (!luhn(m)) return m;
    const r = maskPreserveGroups(m);
    return `${r.masked} [fp:${r.fingerprint}]`;
  });
  return s;
}

/**
 * Sanitize an object by recursively processing its properties.
 *
 * The function checks the type of the input value and handles strings, arrays, and objects accordingly.
 * It sanitizes sensitive string properties based on a predefined regex pattern and recursively sanitizes nested objects or arrays.
 *
 * @param value - The value to sanitize, which can be of any type.
 * @returns The sanitized version of the input value.
 */
export function sanitizeObject(value: any): any {
  if (value === null || value === undefined) return value;
  if (typeof value === "string") return sanitizeString(value);
  if (typeof value !== "object") return value;
  if (Array.isArray(value)) return value.map((v) => sanitizeObject(v));
  const out: Record<string, any> = {};
  for (const k of Object.keys(value)) {
    const v = (value as any)[k];
    const keySensitive = /password|secret|token|api[-_]?key|authorization|mrn|ssn|account|iban|routing/i.test(k);
    if (typeof v === "string") out[k] = keySensitive ? sanitizeString(v) : sanitizeString(v);
    else out[k] = sanitizeObject(v);
  }
  return out;
}

